# Story 1.9 Lessons Learned: Good Faith Letter BMad Agent Implementation

## Overview

This document captures lessons learned from implementing the Good Faith Letter BMad agent (Story 1.9) and fixing all associated tests. It serves as a reference guide for future AI agents implementing similar functionality within the BMad framework.

## Key Implementation Patterns

### 1. BMad Agent Definition Structure

#### Correct AgentDefinition Attributes
The `AgentDefinition` class stores agent metadata as direct attributes, not nested objects:

```python
# ❌ INCORRECT - Tests assumed nested structure
assert agent_def.agent.id == "good-faith-letter"
assert agent_def.dependencies['tasks']

# ✅ CORRECT - Direct attribute access
assert agent_def.id == "good-faith-letter"
assert agent_def.tasks  # Dependencies are stored as separate attributes
```

**Lesson**: Always check the actual dataclass definition before writing tests. The AgentDefinition stores:
- Metadata directly: `id`, `name`, `title`, `icon`, etc.
- Dependencies as separate lists: `tasks`, `templates`, `checklists`, `data`

### 2. Task Handler Implementation

#### Creating Task Handlers
Task handlers should be implemented in the `task_handlers` module and follow this pattern:

```python
# src/ai_agents/bmad_framework/task_handlers/good_faith_letter_handlers.py

async def handle_select_template(
    context: AgentSecurityContext,
    jurisdiction: str,
    **kwargs
) -> Dict[str, Any]:
    """Task-specific handler."""
    # Implementation
    pass

# Export a dispatcher function for tests
async def execute_task(
    task_name: str,
    security_context: Optional[AgentSecurityContext] = None,
    **parameters
) -> Any:
    """Execute task by name."""
    task_handlers = {
        "select-letter-template": handle_select_template,
        # ... other handlers
    }
    handler = task_handlers.get(task_name)
    if not handler:
        raise TaskExecutionError(task_name, f"Unknown task: {task_name}")
    return await handler(security_context, **parameters)
```

**Lesson**: The BMad framework doesn't have a global `execute_task` function. Each agent needs to implement its own task handlers and export them appropriately.

### 3. Template Loader Patterns

#### DocumentTemplate Initialization
The `DocumentTemplate` dataclass requires all metadata fields during initialization:

```python
# ❌ INCORRECT - Missing required fields
template = DocumentTemplate(raw_yaml=data)

# ✅ CORRECT - Provide all required fields with defaults
template = DocumentTemplate(
    type=meta.get("type", "document"),
    subtype=meta.get("subtype", "general"),
    version=meta.get("version", "1.0"),
    title=meta.get("title", "Untitled"),
    description=meta.get("description", ""),
    jurisdiction=meta.get("jurisdiction", "general"),
    raw_yaml=data
)
```

**Lesson**: When parsing YAML into dataclasses, extract and provide all required fields upfront rather than setting them later.

### 4. Async Context Manager Patterns

#### Database Session Handling
Many services use async context managers for resource management:

```python
# ❌ INCORRECT - Treating context manager as coroutine
session = await service._get_db_session()

# ✅ CORRECT - Using as async context manager
async with service._get_db_session() as session:
    # Use session
    pass
```

**Lesson**: Check method implementations to determine if they return values directly or context managers.

### 5. Import Path Conventions

All imports within the Clerk codebase should use absolute imports from `src`:

```python
# ❌ INCORRECT
from ai_agents.bmad_framework.agent_loader import AgentLoader

# ✅ CORRECT
from src.ai_agents.bmad_framework.agent_loader import AgentLoader
```

**Lesson**: The Docker container expects imports to start with `src` as it's the package root.

### 6. Service Method Naming

Services should use consistent method names that match their dependencies:

```python
# ❌ INCORRECT - Method doesn't exist
federal_meta = await self.template_service.get_template_metadata("federal")

# ✅ CORRECT - Use actual method name
federal_meta = await self.template_service.get_template_requirements("federal")
```

**Lesson**: Always verify method signatures in dependent services before using them.

### 7. Mock Patterns for Tests

#### Mocking Async Functions
When mocking async functions, be careful about return values:

```python
# ❌ INCORRECT - Double async wrapping
mock_exec.return_value = AsyncMock(return_value=mock_result)

# ✅ CORRECT - Direct return value
mock_exec.return_value = mock_result
```

#### Mocking Context Managers
For async context managers, create proper mock implementations:

```python
from contextlib import asynccontextmanager

@asynccontextmanager
async def mock_session_context():
    yield mock_session
    
mock_session_local.return_value = mock_session_context()
```

### 8. WebSocket Event Emission

The BMad framework uses `emit_progress_update` for WebSocket events with specific parameters:

```python
# ❌ INCORRECT - Wrong function signature
await emit_agent_event(
    event_type="letter:exported",
    agent_id=self.agent_id,
    data={...}
)

# ✅ CORRECT - Use proper parameters
await emit_progress_update(
    case_id=security_context.case_id,
    agent_id=self.agent_id,
    task_name="export_letter",
    message=f"Letter exported as {format}",
    percentage=100,
    status="completed",
    metadata={...}
)
```

**Lesson**: Check the actual function signatures in imported modules rather than assuming parameter names.

## Testing Best Practices

### 1. Test File Organization

Tests should mirror the source structure:
```
src/ai_agents/bmad_framework/agents/good_faith_letter.yaml
src/ai_agents/bmad_framework/agents/tests/test_good_faith_letter_agent.py
```

### 2. Test Independence

Each test should be self-contained with proper mocks:
```python
# Mock all external dependencies
with patch.object(service.template_service, 'method') as mock:
    # Test specific behavior
    pass
```

### 3. Async Test Patterns

Use `pytest.mark.asyncio` for async tests:
```python
@pytest.mark.asyncio
async def test_async_method():
    # Test async code
    pass
```

### 4. Fixture Usage

Create reusable fixtures for common test objects:
```python
@pytest.fixture
def mock_security_context():
    context = Mock(spec=AgentSecurityContext)
    context.case_id = "test-case-123"
    context.case_name = "Test_Case_2024"
    return context
```

## Common Pitfalls to Avoid

1. **Assuming API Structure**: Always verify the actual implementation before writing tests
2. **Import Path Errors**: Use `src.` prefix for all internal imports
3. **Async/Sync Confusion**: Check if methods are async before using `await`
4. **Mock Return Values**: Ensure mocks return the correct type (value vs. coroutine)
5. **Missing Dependencies**: Create all required handler files and exports
6. **Context Manager Misuse**: Distinguish between functions and context managers

## Recommended Development Workflow

1. **Understand Existing Code**: Read the actual implementations before writing tests
2. **Create Missing Components**: Implement required handlers, loaders, etc.
3. **Fix Import Paths**: Ensure all imports use the correct `src.` prefix
4. **Update Mock Patterns**: Match mocks to actual function signatures
5. **Run Tests Iteratively**: Fix one test at a time to isolate issues
6. **Document Patterns**: Update this guide with new learnings

## Conclusion

The Good Faith Letter BMad agent implementation demonstrates the importance of understanding the framework's actual structure rather than making assumptions. By following these patterns and avoiding common pitfalls, future agent implementations can be more efficient and maintainable.